Rust是由Mozilla主導開發的通用、編譯型程式語言。設計準則為「安全、並行、實用」，支援函數式、並行式、程序式以及物件導向的編程風格。

Rust語言原本是Mozilla員工Graydon Hoare的私人計畫，而Mozilla於2009年開始贊助這個計畫，並且在2010年首次揭露了它的存在。也在同一年，其編譯器原始碼開始由原本的OCaml語言轉移到用Rust語言，進行bootstrapping工作，稱做rustc，並於2011年實際完成。這個可自我編譯的編譯器在架構上採用了LLVM做為它的後端。

第一個有版本號的Rust編譯器於2012年1月釋出。Rust 1.0是第一個穩定版本，於2015年5月15日釋出。

Rust是在完全開放的情況下進行開發，並且相當歡迎社區的回饋。在1.0穩定版之前，語言設計也因為透過撰寫Servo網頁瀏覽器排版引擎和rustc編譯器本身，而有進一步的改善。雖然它由Mozilla資助，但它其實是一個共有專案，有很大部分的代碼是來自於社區的貢獻者。

Rust的設計目標之一，是要使設計大型的網際網路客戶端和伺服器的任務變得更容易。因此更加強調安全性、記憶體組態、以及並行處理等方面的特性。

Rust的效能

在效能上，具有額外安全保證的代碼會比C++慢一些，例如對Rust的陣列進行操作時預設會檢查索引是否越界，而C++則不會，但是如果以C++也手工提供保證的情況下，則兩者效能上是相似的。

語法

Rust的語法設計，與C語言和C++相當相似，區塊（block）使用大括號隔開，流程控制的關鍵字如if、else、while等等。在保持相似性的同時，Rust也加進了新的關鍵字，如用於模式匹配（pattern matching）的match（與switch相似）則是使用C／C++系統程式語言的人會相對陌生的概念。儘管在語法上相似，Rust的語義（semantic）和（C／C++）非常不同。

記憶體安全
為了提供記憶體安全，它的設計不允許空指標和懸空指標 。 資料只能透過固定的初始化形態來建構，而所有這些形態都要求它們的輸入已經分析過了。Rust有一個檢查指標生命期間和指標凍結的系統，可以用來預防在C++中許多的型別錯誤，甚至是用了智慧型指標功能之後會發生的型別錯誤。

記憶體管理
早期的Rust雖然有垃圾回收系統，但非如Java或.NET平台的全自動垃圾回收。Rust 1.0已不再使用垃圾回收器，而是全面改用基於參照計數的智慧型指標來管理記憶體。

類型與多型

它的型別系統直接地模仿了Haskell語言的type class概念，並把它稱作「traits」，可以把它看成是一種ad hoc多型。Rust的作法是透過在宣告型別變數（type variable）的時候，在上面加上限制條件。至於Haskell的高階型別變數（Higher-kinded polymorphism）則還未支援。

型別推導也是Rust提供的特性之一，使用let語法宣告的變數可以不用宣告型別，亦不需要初始值來推斷型別。但如果在稍後的程式中從未指派任何值到該變數，編譯器會發出編譯時（compile time）錯誤。 函式可以使用泛型化參數（generics），但是必須綁定Trait。沒有任何方法可以使用方法或運算子，又不宣告它們的型別，每一項都必確明確定義。

Rust的物件系統是基於三樣東西之上的，即實作（implementation）、Trait以及結構化資料（如struct）。實作的角色類似提供Class關鍵字的程式語言所代表的意義，並使用impl關鍵字。繼承和多型則透過Trait實現，它們使得方法（method）可以在實作中被定義。結構化資料用來定義欄位。實作和（trait）都無法定義欄位，並且只有（trait）可以提供繼承，藉以躲避C++的「鑽石繼承問題」（菱型缺陷）。